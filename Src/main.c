/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
jjjjjjjjjjjjjjjjjjjjjjjj
aasdasffe ivmeovmaoscp,afomgringws9aoicpmd bjkrbvsiuadojcpkla. b

#include <stdint.h>
#include "HW_types.h"
#include "RCC_utils.h"
#include "GPIO_utils.h"
#include "RTC_utils.h"
#include "PWR_utils.h"
//#include "stm32f1xx.h"
//#include "core_cm3.h"
#include "SCB_registers.h"
#include "IWDG_registers.h"
#include "EXTI_utils.h"
#include "cmsis_gcc.h"

#include "SPI_utils.h"
#include "AFIO_utils.h"
#include "DMA_utils.h"
#include "NRF24/nrf24l01.h"

#include "I2C_utils.h"

#define NOT_USE_STM32F103XB_HEADER
#define USE_LSI

#if defined(USE_STM32F103XB_HEADER)
	#warning "Conflito"
#endif

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define __SUPPRESS_UNUSED(name) \
	    _Pragma("GCC diagnostic push") \
	    _Pragma("GCC diagnostic ignored \"-Wunused-but-set-variable\"") \
		name; \
	    _Pragma("GCC diagnostic pop")

#define __SUPPRESS_UNUSED_VARIABLE(name)		__SUPPRESS_UNUSED(name)

#define __SUPPRESS_UNUSED_EXTERN(type, name)	__SUPPRESS_UNUSED(extern type name)

#define __UNUSED_RAW(type, n)	__attribute__((unused)) type n
#define __UNUSED(n) 			__UNUSED_RAW(int, n)
#define UNUSED(n) 				(void)(n)

#define __WEAK					__attribute__((weak))
#define __USED					__attribute__((used))


static __attribute__((used)) void sleep_mode();
static __attribute__((used)) void stop_mode();
static __attribute__((used)) void standby_mode();

__SUPPRESS_UNUSED_EXTERN(int, _etext);
__SUPPRESS_UNUSED_EXTERN(int, _sdata);
__SUPPRESS_UNUSED_EXTERN(int, _edata);
__SUPPRESS_UNUSED_EXTERN(int, _sbss);
__SUPPRESS_UNUSED_EXTERN(int, _ebss);
__SUPPRESS_UNUSED_EXTERN(int, _end);
__SUPPRESS_UNUSED_EXTERN(int, _estack);
__SUPPRESS_UNUSED_EXTERN(int, _flash);
__SUPPRESS_UNUSED_EXTERN(int, _sflash);
__SUPPRESS_UNUSED_EXTERN(int, _eflash);

#define TX_ADDRESS			0xAABBCCDDEE

#define ADDRESS_GENERATOR(val) { \
    (uint8_t)((val) >> 0),  \
    (uint8_t)((val) >> 8),  \
    (uint8_t)((val) >> 16), \
    (uint8_t)((val) >> 24), \
    (uint8_t)((val) >> 32)  \
}

/*
unsigned long int addr64 = TX_ADDRESS;
// Quebra em bytes: LSB â†’ MSB
unsigned char tx_address[5] = {
    (unsigned char)(addr64 >> 0),   // 0xEE
    (unsigned char)(addr64 >> 8),   // 0xDD
    (unsigned char)(addr64 >> 16),  // 0xCC
    (unsigned char)(addr64 >> 24),  // 0xBB
    (unsigned char)(addr64 >> 32)   // 0xAA
};

unsigned char tx_address[5] = ADDRESS_GENERATOR(TX_ADDRESS);
*/
unsigned char tx_address[5] = {0xEE, 0xDD, 0xCC, 0xBB, 0xAA};
unsigned char rx_address[5] = {0xEE, 0xDD, 0xCC, 0xBB, 0xAA};
unsigned char tx_data[] = "HELLO WORLD\n";
unsigned char rx_data[32] = {};

int main(void)
{
	__UNUSED(data) = ((int)&_edata) - (int)&_sdata;
	__UNUSED(bss) = ((int)&_ebss) - (int)&_sdata;
	__UNUSED(size_app) = ((int)&_eflash) - (int)&_sflash;
	__UNUSED(bank) = size_app/1024;
	__UNUSED(setor) = size_app%1024;

	system_clock_config();
	gpio_init_config();
	afio_init_config();
	spi_init_config();
	//spi_interrupt_config()
	//spi_dma_config();
	//dma_init_config();
	//unsigned int ads = SPI1+SPI_DR;
	ENABLE_SPE_SPI();
	//dma_set_channel_config(2, SPI1+SPI_DR, (unsigned int)tx_data, 12);

	secondary_clock_config();
	//watchdog_init_config();

	rtc_init_config();
	rtc_set_config();

	//char lock_key = lock_key_write_sequence(0x2FFF);
	/*
	if((HW_REG(RCCA+RCC_CSR) & (1<<29)) == (1<<29)){
		HW_REG(RCCA+RCC_CSR) |= 1<<24;
		//HW_REG(GPIO_C+GPIOx_BSRR) = (1<<29);	//Set C13
		//for(int i=0;i<100000;i++);
	}
	*/
	__SUPPRESS_UNUSED(volatile int standbymode = 0;);
	if((HW_REG(PWR+PWR_CSR) & PWR_CSR_SBF) == PWR_CSR_SBF){
		standbymode = 1;
		HW_REG(PWR+PWR_CR) |= PWR_CR_CSBF;


		//HW_REG(GPIO_C+GPIOx_BSRR) = (1<<29);	//Set C13
		//for(int i=0;i<100000;i++);/*Delay*/
		//HW_REG(GPIO_C+GPIOx_BSRR) = (1<<13);	//Reset C13
		//for(int i=0;i<100000;i++);/*Delay*/
		//HW_REG(GPIO_C+GPIOx_BSRR) = (1<<29);	//Set C13
		//for(int i=0;i<100000;i++);/*Delay*/

		stop_mode();
		//for(int i=0;i<100000;i++);
		//HW_REG(GPIO_C+GPIOx_BSRR) &= ~(1<<29);	//Set C13
		//for(int i=0;i<100000;i++);
		//HW_REG(GPIO_C+GPIOx_BSRR) = (1<<29);	//Set C13
		//for(int i=0;i<100000;i++);

		//CLEAR_BIT(PWR+PWR_CSR, PWR_CSR_EWUP);
		//HW_REG(PWR+PWR_CSR) &= ~PWR_CSR_EWUP;
	}

	/*
	if((HW_REG(RCCA+RCC_CSR) & (1<<29)) != (1<<29)){
		for(int i=0;i<100000;i++);
	}

	volatile int standbymode = 0;
	if((HW_REG(PWR+PWR_CSR) & PWR_CSR_SBF) == PWR_CSR_SBF){
		standbymode = 1;
		HW_REG(PWR+PWR_CR) |= PWR_CR_CSBF;

		HW_REG(GPIO_C+GPIOx_BSRR) = (lock_key<<29);	//Set C13

		CLEAR_BIT(PWR+PWR_CSR, PWR_CSR_EWUP);
		HW_REG(PWR+PWR_CSR) &= ~PWR_CSR_EWUP;
	}

	volatile int rtc_or_wkup = 0;
	if((HW_REG(PWR+PWR_CSR) & PWR_CSR_WUF) == PWR_CSR_WUF){
		rtc_or_wkup = 1;
	}
	*/

	//ENABLE_SPE_SPI();
	nrf24_init_config();
	nrf24_rx_mode(rx_address, 10);
	/*
	nrf24_tx_mode(tx_address, 10);

	char rx = 0;
	ENABLE_SPE_SPI();
	SELECT_CS_PIN_SPI();
	rx = spi_transmit_data(rx_data, 2);
	UNSELECT_CS_PIN_SPI();

	if(nrf24_transmit(tx_data) == 1)
	{
		HW_REG(GPIO_C+GPIOx_ODR) ^= (1<<13);	//Set C13
	}

	if(is_data_available(1) == 1)
	{
		nrf24_receive(rx_data);
		HW_REG(GPIO_C+GPIOx_ODR) ^= (1<<13);	//Set C13
	}
	*/
	/*
	i2c_init_config();
	i2c_start();
	i2c_set_address(0x00);
	i2c_transmit_data(tx_data, 1);
	i2c_stop();
	*/
    /* Loop forever */
	uint32_t last_time = rtc_get_time();
	for(;;)
	{
		//HW_REG(GPIO_C+GPIOx_BSRR) = (1<<29);	//Set C13
		//for(int i=0;i<100000;i++);/*Delay*/

		//HW_REG(GPIO_C+GPIOx_BSRR) = (1<<13);	//Reset C13
		//for(int i=0;i<100000;i++);/*Delay*/
		//sleep_mode();
		//stop_mode();
		//standby_mode();

		uint32_t now = rtc_get_time();
		if ((now - last_time) >= 1) {
			/*
			if(nrf24_transmit(tx_data) == 1)
			{
				HW_REG(GPIO_C+GPIOx_ODR) ^= (1<<13);	//Toggle C13
			}
			*/
			if(is_data_available(1)){
				nrf24_receive(rx_data);
				HW_REG(GPIO_C+GPIOx_ODR) ^= (1<<13);	//Toggle C13
			}

			//HW_REG(GPIO_C+GPIOx_ODR) ^= (1<<13);	//Toggle C13
			last_time = now;
		}
	}
}

static __attribute__((used)) void sleep_mode(){
	HW_REG(SCB+SCB_SCR) &= ~SCB_SCR_SLEEPDEEP; //Clear DEEPSLEEP
	__WFI();
}

static __attribute__((used)) void stop_mode(){
	HW_REG(SCB+SCB_SCR) |= SCB_SCR_SLEEPDEEP; //Set DEEPSLEEP
	HW_REG(PWR+PWR_CR) &= ~PWR_CR_PDDS;	//Clear PDDS
	HW_REG(PWR+PWR_CR) &= ~PWR_CR_LPDS;	// Voltage regulator on during Stop mode
	//HW_REG(PWR+PWR_CR) |= PWR_CR_LPDS;	//Voltage regulator in low-power mode
	HW_REG(EXTI+EXTI_PR) |= 0x000FFFFF;
	HW_REG(RTC+RTC_CRL) &= ~RTC_CRL_ALRF;
	__WFI();
}

static __attribute__((used)) void standby_mode(){
	//HW_REG(RCCA+RCC_APB1ENR) |= RCC_PWREN_CLOCK_ENABLE;
	//HW_REG(RCCA+RCC_APB1ENR) |= RCC_BKPEN_CLOCK_ENABLE;
	//HW_REG(PWR+PWR_CR) &= ~(1<<4);
	//HW_REG(RCCA+RCC_CFGR) |= (0x3<<14);	//ADCPRE divided by 8
	//HW_REG(RCCA+RCC_CFGR) |= (0x7<<11);	//PPRE2 divided by 16
	//HW_REG(RCCA+RCC_CFGR) |= (0x7<<8);	//PPRE1 divided by 16
	//HW_REG(RCCA+RCC_CFGR) |= (0xF<<4);	//SYSCLK divided by 512
	//HW_REG(PWR+PWR_CSR) |= PWR_CSR_EWUP;
	HW_REG(SCB+SCB_SCR) |= SCB_SCR_SLEEPDEEP; //Set DEEPSLEEP
	HW_REG(PWR+PWR_CR) |= PWR_CR_PDDS;	//Set PDDS
	HW_REG(PWR+PWR_CR) |= PWR_CR_CWUF;	//Clear Wakeup flag
	while((HW_REG(PWR+PWR_CSR) & PWR_CSR_WUF) == PWR_CSR_WUF);
	__WFI();
}
