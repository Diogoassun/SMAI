/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "HW_types.h"
#include "RCC_utils.h"
#include "GPIO_utils.h"
#include "RTC_utils.h"
#include "PWR_utils.h"
//#include "stm32f1xx.h"
//#include "core_cm3.h"
#include "SCB_registers.h"
#include "IWDG_registers.h"
#include "EXTI_utils.h"
#include "cmsis_gcc.h"

#include "SPI_utils.h"
#include "AFIO_utils.h"
#include "DMA_utils.h"
#include "NRF24/nrf24l01.h"

#include "PWM_utils.h"
#include "IR_utils.h"
#include "USART_utils.h"
#include "I2C_utils.h"

#include "SYSTICK_utils.h"

#include "DEBUG.h"

#define NOT_USE_STM32F103XB_HEADER
#define USE_LSI

#if defined(USE_STM32F103XB_HEADER)
	#warning "Conflito"
#endif

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define __WEAK					__attribute__((weak))
#define __USED					__attribute__((used))


static __attribute__((used)) void sleep_mode();
static __attribute__((used)) void stop_mode();
static __attribute__((used)) void standby_mode();

/*
#define TX_ADDRESS			0xAABBCCDDEE

#define ADDRESS_GENERATOR(val) { \
    (uint8_t)((val) >> 0),  \
    (uint8_t)((val) >> 8),  \
    (uint8_t)((val) >> 16), \
    (uint8_t)((val) >> 24), \
    (uint8_t)((val) >> 32)  \
}

unsigned char tx_address[5] = ADDRESS_GENERATOR(TX_ADDRESS);
*/

//unsigned char tx_address[5] = {0x02, 0xDD, 0xCC, 0xBB, 0xAA};
unsigned char rx_address[5] = {0x02, 0xDD, 0xCC, 0xBB, 0xAA};
//unsigned char rx_address[5] = {0x02, 0xDD, 0xCC, 0xBB, 0xAA};
//unsigned char tx_data[] = "HELLO WORLD\n";

volatile unsigned char pipe_number;
volatile unsigned int receive_pd;
volatile unsigned int state_listenig_timeout;

typedef enum {
    STATE_IDLE,           // Ocioso, esperando para iniciar o próximo ciclo
    STATE_BROADCASTING,   // Enviando a requisição para todos os nós
    STATE_LISTENING,      // Ouvindo as respostas dos nós
    STATE_PROCESSING      // Processando os dados recebidos e imprimindo
} FSM_State;

typedef enum {
    NODE_UNKNOWN,
    NODE_REQUEST_PENDING, // Aguardando resposta do nó
    NODE_DATA_RECEIVED    // Dados recebidos com sucesso
} NodeStatus;

typedef struct {
    unsigned char address[5];
    NodeStatus status;
    unsigned char received_data[32];
} AuxiliaryNode;

/*
*/

#define MAX_NODES		6

unsigned char rx_addr[6][5] = {
		{0x02, 0xDD, 0xCC, 0xBB, 0xAA},
		{0x06, 0xDD, 0xCC, 0xBB, 0xAA},
		{0x01, 0xDD, 0xCC, 0xBB, 0xAA},
		{0x03, 0xDD, 0xCC, 0xBB, 0xAA},
		{0x04, 0xDD, 0xCC, 0xBB, 0xAA},
		{0x05, 0xDD, 0xCC, 0xBB, 0xAA}
};

int main(void)
{
	//DEBUG_MODE_ON();
	//DEBUG_MODE_OFF();

	system_clock_config();
	gpio_init_config();
	delay_ir_init();
	ir_init_pwm();
	afio_init_config();
	gpio_interrupt_config();
	spi_init_config();
	//spi_interrupt_config()
	spi_dma_config();
	dma_init_config();


	ENABLE_SPE_SPI();
	//dma_set_channel_config(2, SPI1+SPI_DR, (unsigned int)tx_data, 12);
	//dma_set_channel_config(2, SPI1+SPI_DR, (unsigned int)rx_data, 12);

	secondary_clock_config();
	//watchdog_init_config();

	rtc_init_config();
	rtc_set_config();

	if((HW_REG(PWR+PWR_CSR) & PWR_CSR_SBF) == PWR_CSR_SBF){
		HW_REG(PWR+PWR_CR) |= PWR_CR_CSBF;

		stop_mode();

		//CLEAR_BIT(PWR+PWR_CSR, PWR_CSR_EWUP);
		//HW_REG(PWR+PWR_CSR) &= ~PWR_CSR_EWUP;
	}

	/*
	if((HW_REG(RCCA+RCC_CSR) & (1<<29)) != (1<<29)){
		for(int i=0;i<100000;i++);
	}

	volatile int rtc_or_wkup = 0;
	if((HW_REG(PWR+PWR_CSR) & PWR_CSR_WUF) == PWR_CSR_WUF){
		rtc_or_wkup = 1;
	}
	*/

	//ENABLE_SPE_SPI();
	/*
	nrf24_init_config();
	nrf24_multiceiver(rx_address, 10);
	nrf24_tx_mode_with_enaa(tx_address, 10);
	nrf24_tx_mode(tx_address, 10);
	nrf24_rx_mode(rx_address, 10);

	char rx = 0;
	ENABLE_SPE_SPI();
	SELECT_CS_PIN_SPI();
	rx = spi_transmit_data(rx_data, 2);
	UNSELECT_CS_PIN_SPI();
	*/

	/*
	i2c_init_config();
	i2c_start();
	i2c_set_address(0x00);
	i2c_transmit_data(tx_data, 1);
	i2c_stop();
	*/

	usart1_clock_config();
	usart1_gpio_config();
	usart1_init_config();

	AuxiliaryNode networkNodes[MAX_NODES];
	volatile unsigned char rx_data[6][32] = {};
	FSM_State current_state = STATE_IDLE;

	/* Loop forever */
	unsigned int last_time = rtc_get_time();
	for(;;)
	{

		//sleep_mode();
		//stop_mode();
		//standby_mode();

		//if(systick_countflag()){
			//SYSTICK_EXCEPTION_DISABLE();
			//HW_REG(GPIO_C+GPIOx_ODR) ^= (1<<13);	//Toggle C13
		//}

		/*
		if (command_ready) {
			command_ready = 0;
			process_command(rx_buffer);
		}
		*/


		unsigned int now = rtc_get_time();
		if ((now - last_time) >= 1) {

			switch(current_state){
				case STATE_IDLE:
					current_state = STATE_BROADCASTING;
					break;

				case STATE_BROADCASTING:
					for(int i = 0; i < MAX_NODES ;i++) {
						nrf24_init_config();
						nrf24_tx_mode((unsigned char*)(rx_addr+i), 10);
						// Habilitar auto-ack
						//nrf24_tx_mode_with_enaa((unsigned char*)(rx_addr+i), 10);

						//if(nrf24_transmit_no_ack((unsigned char*)(rx_addr+i)) == 1)
						if(nrf24_transmit((unsigned char*)(rx_addr+i)) == 1)
						{
							HW_REG(GPIO_C+GPIOx_ODR) ^= (1<<13);	//Toggle C13
							for(int i=0;i<100000;i++){};
							networkNodes[i].status = NODE_REQUEST_PENDING;
						}
					}
					nrf24_init_config();
					nrf24_multiceiver(rx_address, 10);

					state_listenig_timeout = 0;

					systick_init_config(1000*1000*1);
					/*
					while(1){};
					*/

					current_state = STATE_LISTENING;
					break;

				case STATE_LISTENING:
					for(int node_id = 0; node_id < MAX_NODES ; node_id++) {
						pipe_number = read_pipe();
						//pipe_number = read_security_pipe(rx_data);

						//if(is_data_available(1) == 1){}
						if((pipe_number != 6) && (pipe_number != 7))
						{
							//networkNodes[pipe_number].status = NODE_DATA_RECEIVED;
							nrf24_receive((unsigned char*)(rx_data+pipe_number));
							receive_pd = nrf24_read_reg(NRF24L01_RPD);
							//HW_REG(GPIO_C+GPIOx_ODR) ^= (1<<13);	//Toggle C13
						}
					}

					if(state_listenig_timeout == 1){
						state_listenig_timeout = 0;
						//SYSTICK_EXCEPTION_DISABLE();
						current_state = STATE_PROCESSING;
					}

					break;

				case STATE_PROCESSING:
					/*
					unsigned int umidade = ( ((unsigned int)buffer[1] << 16) | ((unsigned int)buffer[2] << 8) | (buffer[3]) ) >> 4 ;
					unsigned int temperatura = ((unsigned int)(buffer[3]&0x0F) << 16) | ((unsigned int)buffer[4] << 8) | (unsigned int)buffer[5] ;

					umid = ((float)umidade / 1048576.0f) * 100.0f;
					temp = ((float)temperatura / 1048576.0f) * 200.0f - 50.0f;
					*/
					for(int node_id = 0; node_id < MAX_NODES ; node_id++) {
						/*
						if (networkNodes[node_id].status == NODE_DATA_RECEIVED)
						{
							rx_data[node_id][0];
							uart_write_int_ln(umidade);
							uart_write_int_ln(temperatura);
							uart_write("Recebido\r\n");
						}
							*/
					}

					current_state = STATE_IDLE;
					break;

				default:

					break;
			}

			last_time = now;
		}
	}
}

static __attribute__((used)) void sleep_mode(){
	HW_REG(SCB+SCB_SCR) &= ~SCB_SCR_SLEEPDEEP; //Clear DEEPSLEEP
	__WFI();
}

static __attribute__((used)) void stop_mode(){
	HW_REG(SCB+SCB_SCR) |= SCB_SCR_SLEEPDEEP; //Set DEEPSLEEP
	HW_REG(PWR+PWR_CR) &= ~PWR_CR_PDDS;	//Clear PDDS
	HW_REG(PWR+PWR_CR) &= ~PWR_CR_LPDS;	// Voltage regulator on during Stop mode
	//HW_REG(PWR+PWR_CR) |= PWR_CR_LPDS;	//Voltage regulator in low-power mode
	HW_REG(EXTI+EXTI_PR) |= 0x000FFFFF;
	HW_REG(RTC+RTC_CRL) &= ~RTC_CRL_ALRF;
	__WFI();
}

static __attribute__((used)) void standby_mode(){
	//HW_REG(RCCA+RCC_APB1ENR) |= RCC_PWREN_CLOCK_ENABLE;
	//HW_REG(RCCA+RCC_APB1ENR) |= RCC_BKPEN_CLOCK_ENABLE;
	//HW_REG(PWR+PWR_CR) &= ~(1<<4);
	//HW_REG(RCCA+RCC_CFGR) |= (0x3<<14);	//ADCPRE divided by 8
	//HW_REG(RCCA+RCC_CFGR) |= (0x7<<11);	//PPRE2 divided by 16
	//HW_REG(RCCA+RCC_CFGR) |= (0x7<<8);	//PPRE1 divided by 16
	//HW_REG(RCCA+RCC_CFGR) |= (0xF<<4);	//SYSCLK divided by 512
	//HW_REG(PWR+PWR_CSR) |= PWR_CSR_EWUP;
	HW_REG(SCB+SCB_SCR) |= SCB_SCR_SLEEPDEEP; //Set DEEPSLEEP
	HW_REG(PWR+PWR_CR) |= PWR_CR_PDDS;	//Set PDDS
	HW_REG(PWR+PWR_CR) |= PWR_CR_CWUF;	//Clear Wakeup flag
	while((HW_REG(PWR+PWR_CSR) & PWR_CSR_WUF) == PWR_CSR_WUF);
	__WFI();
}
